/* Modified by Fernando Lorenzo on December 13, 2003 to compile with Superlu 3.0 *//* ++++++ This file will not work if Superlu 1.0 is used ++++++++++++*//*    Copyright (C) 2000  Dennis Roddeman    email: dennis.roddeman@feat.nl    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation     59 Temple Place, Suite 330, Boston, MA, 02111-1307, USA*/#include "tnsuplu.h"#if ( SUPERLU_USE || SUPERLU_MT_USE || SUPERLU_DIST_USE )#if SUPERLU_USE #include "slu_ddefs.h"#elif SUPERLU_MT_USE#include "pdsp_defs.h"#elif SUPERLU_DIST_USE#include <math.h>#include "superlu_ddefs.h"#endif#endif#include "slu_util.h" long int solve_superlu( double *superlu_A, int *superlu_asub,  int *superlu_xa, int superlu_nnz, double solve_b[], long int solve_nlocal,  long int nthread ){  int n ,info;#if SUPERLU_DIST_USE      SuperMatrix A;  int_t nprow=1, npcol=1, nrhs=1;  SuperLUStat_t stat;  superlu_options_t options;  ScalePermstruct_t ScalePermstruct;  LUstruct_t LUstruct;  gridinfo_t grid;  double *berr;  int iam, count;#else   SuperMatrix A, L, U, B;  NCformat *Astore;  superlu_options_t options;  SuperLUStat_t stat;  mem_usage_t   mem_usage;  int *perm_r, *perm_c;  int perm_spec;  int nrhs;    #endif/* Create Matrix A in the format expected by SuperLU */#if SUPERLU_DIST_USE    /*  get number of processors nprow, npcol */  MPI_Comm_size(MPI_COMM_WORLD, &count);  nprow=count; npcol=1;/* Initialize superlu process grid */  superlu_gridinit(MPI_COMM_WORLD,nprow,npcol,&grid);  iam  = grid.iam;/* if we dont belong to this grid , bug out  */  if (iam >= nprow*npcol ) goto out;    #endif  n = (int) solve_nlocal;#if SUPERLU_DIST_USE      if ( !iam ) {  /* broadcast matrices to other processes */    MPI_Bcast(&n,1,mpi_int_t,0,grid.comm);    MPI_Bcast(&superlu_nnz,1,mpi_int_t,0,grid.comm);    MPI_Bcast(superlu_A,superlu_nnz,MPI_DOUBLE,0,grid.comm);    MPI_Bcast(superlu_asub,superlu_nnz,mpi_int_t,0,grid.comm);    MPI_Bcast(superlu_xa,n+1,mpi_int_t,0,grid.comm);  } else {/* receive matrices from proc 0  */    MPI_Bcast(&n,1,mpi_int_t,0,grid.comm);    MPI_Bcast(&superlu_nnz,1,mpi_int_t,0,grid.comm);/* allocate storage for compressed column rep */    dallocateA(n,superlu_nnz,&superlu_A,&superlu_asub,&superlu_xa);    MPI_Bcast(superlu_A,superlu_nnz,MPI_DOUBLE,0,grid.comm);    MPI_Bcast(superlu_asub,superlu_nnz,mpi_int_t,0,grid.comm);    MPI_Bcast(superlu_xa,n+1,mpi_int_t,0,grid.comm);  }    #endif /* Set the default input options: options.Fact = DOFACT; options.Equil = YES; options.ColPerm = COLAMD; options.DiagPivotThresh = 1.0; options.Trans = NOTRANS; options.IterRefine = NOREFINE; options.SymmetricMode = NO; options.PivotGrowth = NO; options.ConditionNumber = NO; options.PrintStat = YES;*/    set_default_options(&options);/*  create compressed column matrix for A  */   dCreate_CompCol_Matrix( &A, n, n, superlu_nnz, superlu_A, superlu_asub,     superlu_xa, SLU_NC, SLU_D, SLU_GE );/*    Astore = A.Store;   printf("Dimension %dx%d; # nonzeros %d\n", A.nrow, A.ncol ); */     /* Create right-hand side matrix B. */   nrhs = 1;#if ( SUPERLU_USE || SUPERLU_MT_USE )      dCreate_Dense_Matrix( &B, n, nrhs, solve_b, n, SLU_DN, SLU_D, SLU_GE );        if ( !(perm_c = intMalloc(n)) ) ABORT("Malloc fails for perm_c[].");    if ( !(perm_r = intMalloc(n)) ) ABORT("Malloc fails for perm_r[].");    #endif/* ---------- Solve ----------*/#if SUPERLU_USE     /*  Initialize Stats vars */  StatInit(&stat);   dgssv( &options, &A, perm_c, perm_r, &L, &U, &B, &stat, &info);    #elif SUPERLU_MT_USE  pdgssv( nthread, &A, perm_c, perm_r, &L, &U, &B, &info );#elif SUPERLU_DIST_USE    /* set the default input options */   set_default_options(&options);    /*  Initialize ScalePermstruct and LUstruct */  ScalePermstructInit(n,n,&ScalePermstruct);  LUstructInit(n,n,&LUstruct);    /*  Initialize Stats vars */  PStatInit(&stat);     /*  call the linear eqn solver */ if (!(berr = doubleMalloc(nrhs)) ) ABORT("Malloc fails for berr[]."); pdgssvx_ABglobal(&options, &A, &ScalePermstruct, solve_b, n, nrhs,                  &grid, &LUstruct, berr, &stat, &info);     /*  print the stats */ PStatPrint(&stat,&grid);    #endif  /* De-allocate storage */#if ( SUPERLU_USE || SUPERLU_MT_USE )      SUPERLU_FREE(perm_r);  SUPERLU_FREE(perm_c);#elif SUPERLU_DIST_USE  PStatFree(&stat);  Destroy_LU(n,&grid, &LUstruct);  ScalePermstructFree(&ScalePermstruct);  LUstructFree(&LUstruct);  SUPERLU_FREE(berr);    #endif  Destroy_CompCol_Matrix(&A);    #if ( SUPERLU_USE || SUPERLU_MT_USE )      Destroy_SuperMatrix_Store(&B);  Destroy_SuperNode_Matrix(&L);  Destroy_CompCol_Matrix(&U);    #endif#if SUPERLU_DIST_USE    /* release the process grid */out:  superlu_gridexit(&grid);    #endif    if ( info == 0 ) {            printf(" Solution Found - L\\U MB %.3f\ttotal MB needed %.3f\n",               mem_usage.for_lu/1e6, mem_usage.total_needed/1e6);    } else {        printf("dgssv() error returns INFO= %d\n", info);    }if ( info <= n ) { /* factorization completes */            dQuerySpace(&L, &U, &mem_usage);            printf("L\\U MB %.3f\ttotal MB needed %.3f\n",            mem_usage.for_lu/1e6, mem_usage.total_needed/1e6);        }  return 1;}